# Cursor Rules for @cognigy/chat-components-vue

## Project Context

Vue 3 implementation of @cognigy/chat-components library for rendering chat messages.

**Stack:** Vue 3, TypeScript, Vite, Vitest, CSS Modules

**Architecture:**
- Plugin-based message matching (`src/utils/matcher.ts`)
- Main `Message.vue` routes to specific message components
- Context via `useMessageContext()` (provide/inject)
- CSS Modules with `useCssModule()`

## Critical Rules

### 1. TypeScript Typing Philosophy

**Root types (`any`, `unknown`) indicate a design decision, not a solution.**

Neither `any` nor `unknown` should be common. If you're reaching for root types frequently, something is wrong with your type design.

**The `any` vs `unknown` debate is a distraction:**
- `unknown` zealots miss that narrowing requires knowing types anyway (`if (typeof x === 'string')`)
- This is the same work as defining the union type upfront
- Don't use `unknown` as "safer any" - it just adds ceremony

**Decision process:**
1. **Can I define a proper type?** → Define it (interface, union, `Record<string, T>`)
2. **Is this a public API?** → Must define it (this is your contract with consumers)
3. **Is data genuinely dynamic/volatile?** → Use `any` with optional chaining (`data?.id`)
4. **External library gap?** → Use `any` with a comment explaining why

```typescript
// PUBLIC API: Must be typed (this is the contract)
customIcon?: Component | string
onAnalytics?: (event: string, data: AnalyticsEvent) => void

// EXTENSIBILITY: any OK for dynamic keys
[key: string]: any  // i18n, user-defined keys

// PASS-THROUGH: any OK, data flows to external system unchanged
data?: Record<string, any> | null
```

**When `any` is acceptable:** Extensibility points, pass-through data, external library gaps
**When `any` is NOT acceptable:** Public APIs, known shapes, convenience shortcuts

### 2. NEVER Destructure Props

```typescript
// CORRECT
const props = defineProps<Props>()
const value = computed(() => props.value)

// WRONG - breaks reactivity
const { value } = defineProps<Props>()
```

### 3. ALWAYS Import CSS Module in Script

```vue
<script setup lang="ts">
import { useCssModule } from 'vue'
const $style = useCssModule()  // Required!
</script>

<style module>
.wrapper { }
</style>
```

### 4. Use MessageContext for Shared State

```typescript
import { useMessageContext } from '../../composables/useMessageContext'
const { message, config, action, onEmitAnalytics } = useMessageContext()
```

### 5. Test Context Key Must Be Cast as Symbol

```typescript
provide: {
  [MessageContextKey as symbol]: { message, config, action, onEmitAnalytics }
}
```

## Code Style

### Prefer Ranch Over Skyscraper

Write simple, robust code. Avoid:
- Over-engineered abstractions
- Clever one-liners sacrificing clarity
- Deeply nested reactive expressions
- Premature optimization

Prefer:
- Straightforward, explicit code
- Simple single-purpose functions
- Clear variable names
- Flat control flow

### Error Handling

Always explicit, never silent:

```typescript
// WRONG
const text = msg.data._cognigy._webchat.message.text

// CORRECT
const text = message.data?._cognigy?._webchat?.message?.text
if (!text) {
  console.warn('processMessage: no text found', { messageId: message.id })
  return null
}
```

### DRY Principle

- Production code: Eliminate duplication
- Tests: Repetition OK for clarity and isolation

## Component Template

```vue
<template>
  <div :class="$style.wrapper">
    <Typography variant="body-regular">{{ displayText }}</Typography>
  </div>
</template>

<script setup lang="ts">
import { computed, useCssModule } from 'vue'
import { useMessageContext } from '../../composables/useMessageContext'
import Typography from '../common/Typography.vue'

const $style = useCssModule()

interface Props {
  customProp?: string
}

const props = withDefaults(defineProps<Props>(), {
  customProp: 'default',
})

const { message, config, action } = useMessageContext()

const displayText = computed(() => message.text || props.customProp)
</script>

<style module>
.wrapper {
  padding: 16px;
}
</style>
```

## Testing Guidelines

### Write Meaningful Tests

A test should answer: **"What behavior can users expect with these inputs?"**

**✅ Test these:**
- Security (XSS, sanitization)
- Config effects (settings change behavior)
- Interactions (clicks invoke actions)
- Accessibility (ARIA attributes)
- Business logic (routing, formatting)

**❌ Avoid these:**
```typescript
// Bad: Just checks "exists"
expect(wrapper.exists()).toBe(true)

// Bad: CSS class names (brittle)
expect(wrapper.find('.some-class').exists()).toBe(true)

// Bad: Prop is "defined" (proves nothing)
expect(action).toBeDefined()

// Bad: Repetitive identical tests
it('renders JPEG', () => {})
it('renders PNG', () => {})  // Same logic!
```

**✅ Better patterns:**
```typescript
// Good: Verifies actual behavior
expect(wrapper.find('p').text()).toBe('')

// Good: Tests interaction result
await wrapper.find('button').trigger('click')
expect(action).toHaveBeenCalledWith('payload')

// Good: Data-driven for repetitive cases
it.each([['image/jpeg'], ['image/png']])('renders %s', (mime) => {})
```

### Test Template

```typescript
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import Component from '../src/components/Component.vue'
import { MessageContextKey } from '../src/composables/useMessageContext'

describe('Component', () => {
  const createMessage = (overrides = {}) => ({
    text: 'Test',
    source: 'bot' as const,
    timestamp: '123',
    data: {},
    ...overrides,
  })

  const mountComponent = (message = createMessage(), config = {}) => {
    return mount(Component, {
      global: {
        provide: {
          [MessageContextKey as symbol]: {
            message,
            config,
            action: vi.fn(),
            onEmitAnalytics: vi.fn(),
          },
        },
      },
    })
  }

  it('renders message text in paragraph', () => {
    const wrapper = mountComponent()
    expect(wrapper.find('p').text()).toContain('Test')
  })

  it('applies config-based max width', () => {
    const config = { settings: { layout: { botOutputMaxWidthPercentage: 80 } } }
    const wrapper = mountComponent(createMessage(), config)
    expect(wrapper.find('.chat-bubble').attributes('style')).toContain('max-width: 80%')
  })
})
```

## Directory Structure

```
src/
├── components/
│   ├── Message.vue          # Main router
│   ├── common/              # ChatBubble, ActionButtons, Typography
│   └── messages/            # TextMessage, Gallery, List, etc.
├── composables/             # useMessageContext, useSanitize
├── utils/                   # matcher, sanitize, helpers
└── types/                   # TypeScript definitions
```

## Commands

```bash
npm run dev          # Dev server
npm run test         # Run tests
npm run test:watch   # Watch mode
npm run build        # Build
npm run type-check   # Type check
```

## Checklist Before Completion

- [ ] **Public API types define clear contracts** (props, callbacks, exports)
- [ ] `any` only used for acceptable cases (extensibility, pass-through, external lib gaps)
- [ ] Props not destructured
- [ ] CSS modules imported with `useCssModule()`
- [ ] Error cases handled with logging
- [ ] Null/undefined checks at boundaries
- [ ] **Tests verify behavior** (not just "exists" checks)
- [ ] No CSS class existence tests
- [ ] No silent failures
- [ ] Simple, readable code
